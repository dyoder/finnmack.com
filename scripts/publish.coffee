fs = require("fs")
zlib = require("zlib")
{read} = require "fairmont"
{parse} = require "c50n"
{resolve, join, dirname, basename, extname} = require "path"
glob = require "panda-glob"
{log, sh, abort} = require "./operators"

buildPath = resolve("www")
[_, _, environment] = process.argv
{bucket} = parse(read(resolve("s3.cson")))[environment]

remove = ->
  sh "s3cmd del --recursive --force s3://#{bucket}"

put = ({source, destination, mediaType}) ->
  command = ["s3cmd put"]
  command.push("-m 'text/html'") if mediaType?
  command.push("--add-header='content-encoding:gzip'")
  command.push(source)
  command.push("'s3://#{bucket}/#{destination}'")
  sh command.join(" ")

publish = (path) ->

  fullPath = join(buildPath, path)
  
  switch extname(path)
    
    # For .html files, we want to publish without the
    # extension, so we need to declare the media type

    when ".html"
      
      compress fullPath, (gzPath) ->
        put
          source: gzPath
          destination: join(dirname(path), basename(path, ".html"))
          mediaType: "text/html"

    # If a file has already been compressed, publish
    # without the .gz extension. This assumes we're
    # getting rid of the .gz files and this one was 
    # generated by another process.

    when ".gz"
      
      put 
        source: fullPath
        destination: basename(path, ".gz")
    
    # In the default case, compress it and publish it
    # using the original name of the file, no media
    # type needed (because s3 will use the extension).

    else

      compress fullPath, (gzPath) ->
        put
          source: gzPath
          destination: path


compress = (path, callback) ->
  gzPath = "#{path}.gz"
  readStream = fs.createReadStream(path)
  writeStream = fs.createWriteStream(gzPath)
  writeStream.on "finish", -> callback?(gzPath)
  writeStream.on "error", (error) -> console.log error
  readStream.on "error", (error) -> console.log error
  readStream.pipe(zlib.createGzip()).pipe(writeStream)    

remove() # get rid of what's in the bucket
publish(path) for path in glob(buildPath, "**/*")